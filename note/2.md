


### 自动清理构建目录
```
rm -rf ./dist && webpack
rimraf ./dist && webpak
```
更加推荐使用 `clean-webpack-plugin` 默认会删除 `output` 指定的输出目录。

[更多关于clean-webpack-plugin使用](https://www.npmjs.com/package/clean-webpack-plugin)


### css 的增强

```shell
npm install postcss-loader autoprefixer -D
```
同时 `webpack` 的 `css` 编译中添加 `postcss-loader`:
```js
module:{
  rules:[
    {
      test: /\.(scss|css)$/,
      use: [
        // 'style-loader',
        miniCssExtractPlugin.loader,
        'css-loader',
        'postcss-loader',
        'sass-loader'
      ]
    },
  ]
}
```

新建 `postcss.config.js`
```js postcss.config.js
module.exports = {
  plugins: [
    require('autoprefixer')
  ]
}
```
新建 `.browserslistrc`
``` .browserslistrc
> 1%
last 2 versions
```

### css 增强（通过 webpack 转换rem 适配）

```js
npm install px2rem-loader lib-flexible -D
```
```js webpack.config.js
module:{
  rules:[
    {
      test:/\.(scss|css)$/,
      use:[
        'style-loader',
        'css-loader',
        'sass-loader',
        {
          loader:'px2rem-loader',
          options:{
            remUnit:75, // 750设计稿
            remPrecesion:8 // 精确度
          }
        }
      ]
    },
  ]
}
```

### 资源内联
代码层面意义：
* 页面框架的初始化脚本（如引入`lib-flexible`）
* 上报相关打点
* css 内联避免页面闪动  

请求层面意义:
* 减少 HTTP 网络请求数量 (小的图片或者字体内联`url-loader `)

#### HTML 和 JS 内联
使用 `raw-loader` 做资源的内联是不能使用过高版本。
```shell
npm i raw-loader@0.5 -D
```
```js
${ require('raw-loader!./meta.html')}
<script>
 ${ require('raw-loader!babel-loader!./node_modules/lib-flexible/flexible.js')}
</script>
```
#### css 的内联
方案一：借助`style-loader`来完成
[具体查看style-loader配置项](https://www.npmjs.com/package/style-loader)

方案二：借助 `html-inline-css-webpack-plugin`
[具体查看html-inline-css-webpack-plugin](https://www.npmjs.com/package/html-inline-css-webpack-plugin)


### 多页面的打包 MPA
多页面打包基本思路:      
每个页面对应一个`entry`，一个`html-webpack-plugin`    
缺点： 每次新增或者删除页面需要修改 `webpack`配置     
**多页面打包通用方案：**     
动态获取`entry`和设置`html-webpacl-plugin`数量。
利用`glob.sync`
```js
enrty:glob.sync(path.join(__dirname,'./src/*/index.js'))
```
```shell
npm install glob -D
```
相当于市使用了一个约定俗成的，每一个页面的入口都建`index`。同时`src`下面的没一个文件名为多页面中每个页面的名称.
```js 
const setMPA = () => {
  const entry = {}
  const htmlWebpackPlugins = []
  const entryFiles = glob.sync(path.join(__dirname, './src/*/index.js'))
  Object.keys(entryFiles).map(index => {
    console.log()
    const entryFile = entryFiles[index]
    const match = entryFile.match(/src\/(.*)\/index.js/)
    const pageName = match && match[1]
    entry[pageName] = entryFile

    htmlWebpackPlugins.push(new htmlWebpackPlugin({
      template: path.join(__dirname, `./src/${pageName}/index.html`),
      filename: `${pageName}.html`,
      chunks: [`${pageName}`],
      inject: true,
      minify: {
        html5: true,
        collapseWhitespace: true,
        preserveLineBreaks: false,
        minifyCSS: true,
        minifyJS: true,
        removeComments: false
      }
    }))
  })

  return {
    entry,
    htmlWebpackPlugins
  }
}

const { entry, htmlWebpackPlugins } = setMPA();
```

[多页面demo(此时只对prod进行了处理)](https://github.com/xiaopingbuxiao/webpack/tree/master/MPA)


### webpack 中开启 source map

`source map`关键字:    
* eval：使用 eval 包裹模块代码
* source map：产生 .map 文件
* cheap：不包含列信息
* inline：将 .map 作为 DataURL 嵌入，不单独生成 .map 文件
* module：包含 loader 的 sourcemap

[更多sourceMap类型](https://webpack.docschina.org/configuration/devtool/)

对于 `js` 的 `sourceMap` 只需要设置:
```js 
module.exports={
  devtool:'source-map'
}
```
对于 `css` 的 `source-map` 根据 [css-loader](https://www.npmjs.com/package/css-loader) 来设置。
 

 ### 基础库的分离

思路：将 `react`、`react-dom` 等基础包通过`cdn`引入，不打入`bundle`中      
方法：使用`html-webpack-externals-plugin`
```shell
npm install --save-dev html-webpack-externals-plugin
```
增加配置如下:
```js
plugins;[
  new HtmlWebpackExternalsPlugin({
    externals: [
      {
        module: 'react',
        entry: '//unpkg.com/react@16/umd/react.development.js',
        global: 'React',
      },
      {
        module: 'react-dom',
        entry: '//unpkg.com/react-dom@16/umd/react-dom.development.js',
        global: 'ReactDOM',
      },
    ],
  })
]
```





也可以使用`SplitChunksPlugin`来进行基础包的分离。

```js

```





### 利用 SplitChunksPlugin 进行公共脚本的分离

`webpack4` 内置了此插件。      
`chunks` 参数说明:
* async 一步引入的库进行分离(默认)
* initial 同步引入的库进行分离
* all 所有引入的库进行分离(默认)



[SplitChunksPlugin更详细的文档](https://webpack.docschina.org/plugins/split-chunks-plugin/)